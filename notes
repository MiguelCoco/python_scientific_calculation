                                                      python科学计算第二版
CHAPTER 2
Numpy
    提供两种基本的对象：
	      ndarray,存储单一数据类型的多维数组，统称为数组
        
        ufunc,一种能对数组进行数据处理的特殊函数
        
ndarray对象
    创建ndarray对象
	      通过给array（）函数传递python的序列对象来创建函数，如果是多层的嵌套的序列，将创建多维数组
	      a = np.array([1,2,3,4])
        b = np.array([5,6,7,8])
       	c = np.array([[1,2,3,4],[4,5,6,7],[7,8,9,10]])
       
       	b
        		array[5,6,7,8]
       	c
          	array[[1,2,3,4],
                	[4,5,6,7],
                  [7,8,9,10]]
       
		数组的形状可以通过shape属性获得，它是一个描述数组各个轴的长度的元组：
        a.shape  (4,）
        b.shape  (4,)
        c.shape  (3,4)
            数组a的shape属性只有一个元素，因此是一维数组，轴的长度为4；数组c的shape属性有两个元素，因此它是二维数组，第0轴长度为3，第一轴长度为4
    修改数组的shape属性可以保持数组元素个数不变的同时，改变数组各轴的长度
        c.shape = 4,3
        c
            array([[1,2,3],
                   [4,4,5],
                   [6,7,7],
                   [8,9,10]])
			  从(3,4)改为（4,3）并不是对数组进行转置，而是改变轴的长度，数组元素在内存中的位置并没有改变
      
      设置某个轴的元素个数为-1时，将自动计算轴的长度
          c.shape =2,-1
          c
              array([[1,2,3,4,4,5],
                     [6,7,7,8,9,10]])
      使用数组的reshape()方法，可以创建指定形状的新数组，而原数组的形状保持不变
          d = a.reshape(2,2)
          d
              array[[1,2],
                    [3,4]]
          a
              array[1,2,3,4]
              
      数组a和d共用数据存储空间，修改其中任意一个数组的元素，另一个数组的元素会同时修改
          a[1] = 100
          a
              array[1,100,3,4]
          d
              array[[1,100],
                    [3,4]]
     
元素类型
    数组的元素类型可以通过dtype属性获得
        c.dtype
        创建数组是可指定元素类型，float是64位双精度浮点类型，complex是128位双精度复数类型
            a_int32 = np.array([1,2,3],dtype=np.int32)
            a_f=np.array([1,2,3],dtype=float)
            a_c=np.array([1,2,3],dtype=complex)
            np.int32是numpy的函数，float是python内置函数，numpy也有float16、float32函数
        numpy中每种数值类型都有几种字符串表示方式，字符串和类型之间的对应关系都存储在typeDict字典中
            [key for key,value in np.typeDict.items() if value is np.float64]
        完整的类型列表可通过set(np.typeDict.values())    
        通过数值类型也可以创建数值对象
            a = np.int16(200)
            通过数值类型创建的数值取值范围小于标准python数值取值范围
            numpy的数值对象的运算速度比python内置类型的运算速度慢很多，numpy的数组运算速度比python的列表数组快很多
        使用astype()方法可以对数组的元素类型进行转换
            tl = np.array([1, 2, 3, 4], dtype=np.float) 
            t2 = np.array([1, 2, 3, 4], dtype=np.complex) 
            t3 = tl.astype(np.int32) 
            t4 = t2.astype(np.complex64)
            
自动生成数组
    arange([start,] stop[, step,], dtype=None)
        指定开始值、终止值、步长值创建等差数列的一位数组，注意不包含终止值
    linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)
        指定开始值、终止值、元素个数创建等差数列的一维数组，endpoint指定是否包含终值，默认为True
    logspace(start,stop,num=50,endpoint=True,base=10,dtype=None)
        指定开始值、终止值、元素个数、endpoint指定是否包含终值、base指定基数，创建等比数列的一维数组
        np.logspace(0,2,5)
            起始值表示10的0次方，终值10的2次方，元素个数5，基数默认10
        
     empty(shape, dtype=float, order='C')
        指定形状可以是整数或元组、指定类型、order指定以C类型或F类型存储多维数组
        empty只分配数组使用的内存，而不初始化，速度最快
     zeros(shape, dtype=float, order='C')
        指定形状、类型、存储类型
        zeros将数组元素初始化为0
     ones(shape, dtype=None, order='C')
        指定形状、类型、存储类型
        ones将数组元素初始化为1
     full(shape, fill_value, dtype=None, order='C')
        指定形状、指定标量（数值）、类型、存储类型
        将数组元素初始化为某一值
     zeros_like()、ones_like()、empty_like()、full_like()等函数创建与参数数组的形状和类型相同的数组
        因此zeros_ike(a)和zeros(a.shape，a.dtype)的效果相同  
     frombuffer()、fromstring()、fromfile()等函数可以从字节序列(字符串)或文件创建数组       
        fromstring(string, dtype=float, count=-1, sep='')
            指定字符串、数据类型、count指定返回数组的长度
        fromstring会对字符序列进行复制，frombuffer不复制，共享内存    
    fromfunction(function, shape, **kwargs)
        第一个参数是计算数组元素的函数，第二个参数指定数组的形状，必须是序列
        创建九九乘法表二维数组：
            def fun(i,k):
                return (i+1)*(k+1)
            np.fromfunction(fun,(9,9)）
存取元素
    可以使用和列表相同的方式对数组的元素进行存取
    a = np.arange(10)
    a
        array([0,1,2,3,4,5,6,7,8,9])
    
    使用切片下标存取元素
        a[x]:用整数x作下标可以获取数组中第x个元素的值
        a[x:y]:切片作为下标，获取数组的一部分，包括数组中第x个元素的值，不包括第y个元素的值
        a[:y]:切片省略开始下标，开始下标默认为a[0]
        a[:-y]:下标可以使用负数，倒数第y个
        a[x:y:z]切片中第三个参数代表步长
        a[y:x:-z]步长为负时，开始下标必须大于结束下标
        下标还可以用来修改元素的值
        a[2:4] = 100,1001
        a
            array([0,1,100,101,4,,6,7,8,9])
        数组和列表不同的是，通过切片获取的新的数组是原始数据的一个视图，与原始数据共享同一块数据存储空间
    
    使用整数列表存取元素
        使用整数列表存取元素，将使用整数列表作为数组的下标，得到的新数组不再和原始数组共享内存
        a[[1,3,5]]
            array([1,3,5])
            提取a数组中第1、第3、第5个元素
        整数列表下标也可用用来修改元素的值
            a[[1,2,3]] = 11,22,33
            a
                array([0,11,22,33,4,5,6,7,8,9])
        整数数组下标是多维数组，得到的也是多维数组
        
        
多维数组
    多维数组的下标用多个值来表示，numpy采用元组作为数组的下标，元组中的每个元素和数组的每个轴对应
    
    可以将元组保存在一个变量中，用同一个元组存取多个数组
    
    切片（slice）对象
        单独生成切片对象时需要使用slice()创建
        语法
            slice(start,stop,step)忽略的参数可以使用slice(None,None,None)
        numpy提供一个s_对象帮我们创建数组下标（切片），s_实际上是IndexExpression类的对象：
        np.s_[::2,2:]
            (slice(None,None,2),slice(2,None,None))
        
    在多维数组的下标元组中，也可以使用整数元组或列表、整数数组和布尔数组    
        a[(0,1,2,3],[1,2,3,4])会取 a[(0,1)] a[(1,2)] a[(2,3)] a[(3,4)]
        
结构数组
    创建对象（persontype），描述结构类型的各个字段的字典
        字典包括字段名称和字段类型的键值对
    调用array（）创建数组，通过dtype参数指定数组的类型为对象（persontype）
    结构数组的存取和一般数组相同，通过下标能够取得其中的元素，元素看上去像元组，其实是结构
    
    a.tostring和a.tofile可以将数组a以二级制的方式转换成字符串或写入文件
    然后C语言即可读取文件或识别字符串
    
内存结构
    数组对象如何在内存中存储？
        数组的描述信息保存在一个数据结构中，这个结构存储了两种信息（用于保存数据的存储区域和用于描述元素类型的dtype对象），数组对象使用strides属性保存每个轴上相邻的两个元素的地址差，即当某个轴的下标增加1时，数据存储区中的指针所增加的字节数，如果strides属性中的数值正好和对应轴所占据的字节数相同，那么数据在内存中是连续存储的。，通过切片下标得到的新数组是原始数组的视图，和原始数组共享数据存储区域，但新数组的strides属性会发生变化，由于新数组和原数组共享数据存储区域，新数组和原数组的strides属性成倍数关系    
        
        元素在数据存储区中的排列格式有两种：C语言格式和Fotran格式
            C语言中，多维数组的第0轴是最上位的，即第0轴的下标增加1时，元素的地址增加的字节数最多
            Fortran语言中，多维数组的第0轴是最下位的，即第0轴的下标增加1时，元素的地址只增加一个元素的字节数
            更改格式类型可在Order参数设置
            
        数组复制和引用产生的原因？
            切片和整数下标时，数据在数据存储区域中是等间隔的，数组结构的属性不改变，所以共享内存区域
            整数序列、整数数组和布尔数组时，不能保证所取得的数据在数据存储区域中是等间隔的，因此无法共享数据，只能复制
        flags属性描述了数据存储区域的一些属性
            C_CONTIGUOUS:数据存储区域是否是C语言格式的连续区域
            F_CONTIGUOUS:数据存储区域是否是Fortran语言格式的连续区域
            OWNDATA:数组是否拥有此数据存储区域，当一个数组是其他数组的视图时，它不拥有数据存储区域
            
unfuc函数
    unfunc是universal function 的缩写，它是一种能对数组的每个元素进行运算的函数，Numpy内置的许多ufunc函数都是用C语言实现的，因此他们的计算速度非常快
    
    四则运算
        计算两个数组的和add()函数
           np.add(*args, **kwargs)
           add()函数返回一个数组，它的每个元素都是原来两个参数数组的对应元素之和，如果没有指定out参数，创建新的数组，指定out不创建新的数组  
        
            y = xl +x2                      add(xl,x2[,y])
            y = xl -x2                      subtract(xl, x2 [, y])
            y = xl * x2                     multiply(xl, x2 [, y])
            y = xl /x2                      divide(xl，x2 [，y])，如果两个数组的元素为整数，那么爪整数除法
            y = xl /x2                      true_divide(xl，x2 [，y]),总是返回精确的商
            y = xl //x2                     floor_divide(xl，x2 [，y]),总是对返回值取盤
            y = —x                          negative(x [,y])
            y = xl**x2                      power(xl,x2 [, y])
            y = xl % x2                     remainder(xl, x2 [, y]), mod(xl, x2, [, y])

    比较运算
        使用比较运算符对两个数组进行比较，将返回一个布尔数组，每个元素值都是两个数组对应元素的比较结果
            y = x 1 =x2         equal(xl，x2[，y])
            y =xl !=x2          not_equal(xl,x2 [, y])
            y = xl <x2          less(xl, x2, [, y])
            y = xl <=x2         less_equal(xl, x2, [，y])
            y = xl >x2          greater(xl,x2, [,y])
            y = xl >=x2         greater_equal(xl, x2, [，yj)
    布尔运算
        因为python中的布尔运算使用and、or、not等，所以在Numpy中只能用函数，np.logical_and、np.logical_or、np.logical_not
       
    自定义函数
        frompyfunc(func，nin,nout)
            func是计算单个元素的函数，nin是func的输入参数的个数，nout是func的返回值的个数
            注意！新生成的函数ufunc返回的元素类型是object需要调用astype()方法转换类型
    广播
        使用ufunc函数时，要求数组的形状相同，如果不同会进行广播（broadcasting）处理
            1、让所有输入数姐都向其中维数最多的数组看齐，shape属性中不足的部分都通过在前面加1补齐。
            2、输出数组的shape属性是输入数组的shape属性的各个轴上的最大值。
            3、如果输入数组的某个轴的长度为1或与输出数组的对应轴的长度相同，这个数组能够用来计算，否则出错。
            4、当输入数组的某个轴的长度为1吋，沿着此轴运算时都用此轴上的第一组值
        广播计算函数：
            ogrid([start:stop,start:stop])
            mgrid([start:stop,start:stop])
            None可作为下标，将在None的位置创建一个长度为1的新轴
                a[None,:] 等同于 a.reshape(1,-1)
                a[:,None] 等同于 a.reshape(-1,1)
            ix_（）可将两个一维数组转换成可广播的二维数组
            
 多维数组的下标存取
     下标对象，多维数组的下标应该是一个长度和数组的维数相同的元组，如果不是元组，将自动补充为元组，尽可能“显示”的使用元组作为下标
     
        
        
        
        
        
        
        
        
